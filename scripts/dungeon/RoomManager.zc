const MEMORYLIFE = 35;

Class RoomDoor
{
    Line doorLine;
    DoorHelper doorHelper;
    bool isInUse;
    int doorID;
}

Class SightMemory
{
    Actor seenActor;
    int mapTimeSeen;
}

Class RoomManager : Actor
{
    int roomID;
    string user_DoorIDs; //Editor defined
    array <int> doorIDs;
    array <RoomManager> siblingRooms;
    array <RoomDoor> doors;
    bool readyForGen;
    array <SightMemory> seenActors;

    Default
    {
        
    }

    override void PostBeginPlay(void)
    {

    }

    override void Tick(void)
    {
        A_LookEx(32, 0, fov: 360);
        if(target is "Actor")
        {
            SightMemory newSight = new("SightMemory");
            newSight.seenActor = target;
            newSight.mapTimeSeen = level.time;

            int memoryIndex = GetMemoryIndex(target);
            
            if(memoryIndex != -1)
            {
                seenActors[memoryIndex].mapTimeSeen = level.time;
            }
            else
            {
                seenActors.Push(newSight);
            }
            target = null;
        }

        ClearOldMemories();

        if(CVar.GetCVar("DC_DEBUGMODE"))
        {
            if(seenActors.Size() > 0 && level.time % 70 == 0)
            {
                console.printf("I am RoomManager %d and I remember seeing %d entities", roomID, seenActors.Size());
            }
        }
    }

    int GetMemoryIndex(Actor actor)
    {
        for(int i = 0; i < seenActors.Size(); i++)
        {
            if(seenActors[i].seenActor is "Actor")
            {
                return i;
            }
        }
        return -1;
    }

    void ClearOldMemories(void)
    {
        for(int i = 0; i < seenActors.Size(); i++)
        {
            if(level.time - seenActors[i].mapTimeSeen > MEMORYLIFE)
            {
                //console.printf("Forgetting %s", seenActors[i].seenActor.player.GetUserName());
                seenActors.Delete(i);
            }
        }
    }

    bool Setup (int newID)
    {
        if(user_DoorIDs != "")
        {
            SplitUserString(user_DoorIDs);
            user_DoorIDs = "";
            for(int i = 0; i < doorIDs.Size(); i++)
            {
                AddDoor(doorIDs[i]);
            }

            roomID = newID;

            if(CVar.GetCVar("DC_DEBUGMODE"))
            {
                console.printf("RoomManager %d ready for generation", roomID);
            }

            readyForGen = true;
            return true;
        }
        return false;
    }

    //Make a connection to a new or existing RoomManager
    //Add RoomManager to siblings
    bool MakeNewConnection(RoomManager otherRoomManager)
    {
        //Get door to connect to
        int otherDoorIndex = otherRoomManager.GetRandomUnusedDoorIndex();
        if(CVar.GetCVar("DC_DEBUGMODE"))
        {
            console.printf("Selected other door index %d", otherDoorIndex);
        }
        if (otherDoorIndex == -1)
        {
            return false;
        }
        
        //Get door to connect from
        int myDoorIndex = GetRandomUnusedDoorIndex();
        RoomDoor myDoor = doors[myDoorIndex];
        if(CVar.GetCVar("DC_DEBUGMODE"))
        {
            console.printf("Selected my door index %d", myDoorIndex);
        }

        //Add to siblings
        if(siblingRooms.Find(otherRoomManager) != siblingRooms.Size())
        {
            siblingRooms.Push(otherRoomManager);
        }
        if(CVar.GetCVar("DC_DEBUGMODE"))
        {
            console.printf("Self siblings count: %d", siblingRooms.Size());
        }
        
        //Add self to other siblings
        if(otherRoomManager.siblingRooms.Find(self) != siblingRooms.Size())
        {
            otherRoomManager.siblingRooms.Push(self);
        }
        if(CVar.GetCVar("DC_DEBUGMODE"))
        {
            console.printf("Other siblings count: %d", otherRoomManager.siblingRooms.Size());
        }
        RoomDoor otherDoor = otherRoomManager.doors[otherDoorIndex];
        
        //Create the LinePortal
        console.printf("ids: %d, %d", myDoor.doorID, otherDoor.doorID);
        
        ACS_NamedExecuteAlways("SetupLinePortal", 0, myDoor.doorID, otherDoor.doorID);
        OpenDoor(myDoor);
        OpenDoor(otherDoor);
        myDoor.isInUse = true;
        otherDoor.isInUse = true;
        return true;
    }


    void SplitUserString(string inDoorIDs)
    {
        array <string> splitIDs;
        inDoorIDs.Split(splitIDs, ",");
        for (int i = 0; i < splitIDs.Size(); i++)
        {
            doorIDs.Push(splitIDs[i].ToInt());
        }
    }

    //Add new linedef as RoomDoor to doors array
    void AddDoor(int inID)
    {
        LineIdIterator iterator = Level.CreateLineIdIterator(inID);
        array <int> output;
		int currentIndex = 0;
        int doorHelperOffset = 24;
		while(true) {
			currentIndex = iterator.Next();
			if(currentIndex == -1) break;
			output.Push(currentIndex);
		}
        
        //create RoomDoor and assign linedef reference by ID
        RoomDoor newDoor = new("RoomDoor");
        newDoor.doorLine = Level.Lines[output[0]];
        //Set to blocked by default
        newDoor.doorLine.sidedef[Line.front].SetTexture(Side.mid, TexMan.CheckForTexture("BRICK1", TexMan.Type_Any, TexMan.TryAny));
        newDoor.doorLine.flags += (Line.ML_BLOCKING);
        newDoor.isInUse = false;
        newDoor.doorID = inID;

        Vector3 doorCenter = Geometry.GetLineMidPoint(newDoor.doorLine);
        
        double lineAngle = Geometry.GetLineAngle(newDoor.doorLine);
        
        Vector3 offsetPoint = doorCenter + (doorHelperOffset * cos(lineAngle) * -1, doorHelperOffset * sin(lineAngle) * -1, 0);
        
        //console.printf("doorCenter: (%.1f,%.1f,%.1f) \nangle: %.1f \noffsetPoint: (%.1f,%.1f,%.1f)", doorCenter.x, doorCenter.y, doorCenter.z, lineAngle, offsetPoint.x, offsetPoint.y, offsetPoint.z);

        newDoor.doorHelper = DoorHelper(Actor.Spawn("DoorHelper", offsetPoint));
        
        doors.Push(newDoor);
    }

    void OpenDoor(RoomDoor inDoor)
    {
        inDoor.doorLine.sidedef[Line.front].SetTexture(Side.mid, TexMan.CheckForTexture("", TexMan.Type_Any, TexMan.TryAny));
        inDoor.doorLine.flags -= (Line.ML_BLOCKING);
    }

    int GetFirstUnusedDoorIndex(void)
    {
        for (int i = 0; i < doors.Size(); i++)
        {
            if(doors[i].isInUse == false)
            {
                return i;
            }
        }
        return -1;
    }

    int GetRandomUnusedDoorIndex(void)
    {
        array <int> doorIndexes;
        for (int i = 0; i < doors.Size(); i++)
        {
            console.printf("doors[%d].isInUse: %d", i, doors[i].isInUse);
            if(!doors[i].isInUse)
            {
                doorIndexes.Push(i);
            }
        }

        if(doorIndexes.Size() > 1)
        {
            int doorIndex = doorIndexes[random(0, doorIndexes.Size() - 1)];
            return  doorIndex;
        }
        else if(doorIndexes.Size() == 1)
        {
            return doorIndexes[0];
        }
        else
        {
            return -1;
        }
    }
}

Class DoorHelper : Actor
{
    Default
    {
        +SHOOTABLE
        +NOGRAVITY
        Health 999999999999;
    }
    States
    {
        Spawn:
            TNT1 A 1;
        Idle:
            TNT1 A 1
            {
                Health = 999999999999;
            }
            Loop;
    }
}